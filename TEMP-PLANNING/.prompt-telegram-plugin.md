# Implementation Prompt: Telegram Plugin for Ikabot

## Context

You are implementing a Telegram bot plugin for ikabot (a Python automation bot for Ikariam browser game). The codebase uses CLI with menu-based navigation and 25+ functions that read user input via `input()` and display output via `print()`.

**Critical Constraint**: This is a FORK tracking an upstream repository. Zero merge conflicts required.

## Architecture Overview

Implement a **virtual terminal emulator** that:
1. Hijacks `sys.stdin` to read from Telegram message queue
2. Hijacks `sys.stdout` to send output to Telegram via existing `sendToBot()`
3. Runs existing `command_line.menu()` unchanged - it thinks it's CLI
4. All core functions work automatically without modification

**Key Insight**: Plugin only imports `menu()` - no function registry, no metadata, complete decoupling.

## Research Findings Applied

Based on Python 3.8+ best practices (2024):
- Use `contextlib.redirect_stdout()` for stdout capture (standard library, safe cleanup)
- Use `contextlib.redirect_stdin()` for stdin redirection (Python 3.8+)
- Use context managers for automatic resource cleanup
- Prefer minimal abstractions over boilerplate

## File Structure to Create

```
plugins/telegram/
‚îú‚îÄ‚îÄ __init__.py              # Empty
‚îú‚îÄ‚îÄ virtual_terminal.py      # stdin/stdout hijacking (~60 lines)
‚îú‚îÄ‚îÄ bot.py                   # Main coordinator (~80 lines)
‚îú‚îÄ‚îÄ poller.py                # Telegram polling (~40 lines)
‚îî‚îÄ‚îÄ formatter.py             # ANSI ‚Üí Telegram conversion (~30 lines)

telegram_bot.py              # Entry point (~30 lines)
```

**Total: ~240 lines** (minimal implementation)

## Implementation Requirements

### 1. Virtual Terminal (plugins/telegram/virtual_terminal.py)

**Goal**: Create fake stdin/stdout that work with Telegram

```python
from contextlib import contextmanager
from io import StringIO
from queue import Queue
from ikabot.helpers.botComm import sendToBot

class TelegramInputStream:
    """Fake stdin - reads from Telegram message queue"""
    def __init__(self, message_queue):
        self.queue = message_queue

    def readline(self):
        """Block until message available, return with newline"""
        message = self.queue.get(timeout=300)  # 5 min timeout
        return message + "\n"

    def fileno(self):
        return 99  # Fake descriptor

class TelegramOutputStream:
    """Fake stdout - sends to Telegram"""
    def __init__(self, session, formatter):
        self.session = session
        self.formatter = formatter
        self.buffer = []

    def write(self, text):
        """Buffer text, send complete lines"""
        # Split on newlines, send each line converted
        # Use formatter.convert() for ANSI ‚Üí Telegram
        pass

    def flush(self):
        """Send buffered output"""
        if self.buffer:
            sendToBot(self.session, "\n".join(self.buffer))
            self.buffer = []

@contextmanager
def virtual_terminal(session, formatter, message_queue):
    """Context manager for stdin/stdout hijacking"""
    # Save originals
    # Replace with Telegram versions
    # Yield
    # Restore originals in finally block
```

**Key**: Use context manager for safe cleanup, minimal code.

### 2. ANSI Formatter (plugins/telegram/formatter.py)

**Goal**: Convert CLI ANSI escape codes to Telegram Markdown

```python
import re

class ANSIFormatter:
    """Convert ANSI codes to Telegram Markdown"""

    PATTERNS = {
        r'\033\[1;9[1-4]m': '*',   # Bright colors ‚Üí Bold
        r'\033\[0m': '*',           # Reset ‚Üí Close
        r'\033\[[0-9;]+m': '',      # Remove other codes
    }

    def convert(self, text):
        """Apply regex replacements"""
        result = text
        for pattern, replacement in self.PATTERNS.items():
            result = re.sub(pattern, replacement, result)
        return result
```

**Key**: Simple regex, minimal code, no dependencies.

### 3. Telegram Poller (plugins/telegram/poller.py)

**Goal**: Poll Telegram for messages, call handler

```python
from requests import get
import threading
import time

class TelegramPoller:
    """Polls Telegram Bot API for updates"""

    def __init__(self, bot_token, handler):
        self.bot_token = bot_token
        self.handler = handler
        self.last_update_id = 0
        self.running = False

    def start(self):
        """Start polling in background thread"""
        self.running = True
        self.thread = threading.Thread(target=self._poll_loop, daemon=True)
        self.thread.start()

    def _poll_loop(self):
        """Long polling loop"""
        while self.running:
            try:
                response = get(
                    f"https://api.telegram.org/bot{self.bot_token}/getUpdates",
                    params={"offset": self.last_update_id + 1, "timeout": 30}
                ).json()

                for update in response.get("result", []):
                    self.last_update_id = update["update_id"]
                    self.handler(update)
            except:
                time.sleep(5)
```

**Key**: Use existing `requests` library (no new dependencies), simple polling.

### 4. Main Bot (plugins/telegram/bot.py)

**Goal**: Coordinate everything, run menu() in virtual terminal

```python
from queue import Queue
import threading
from ikabot.command_line import menu
from ikabot.helpers.botComm import sendToBot
from plugins.telegram.virtual_terminal import virtual_terminal
from plugins.telegram.formatter import ANSIFormatter
from plugins.telegram.poller import TelegramPoller

class TelegramBot:
    """Main bot - runs ikabot menu via Telegram"""

    def __init__(self, session):
        self.session = session
        self.message_queue = Queue()
        self.formatter = ANSIFormatter()

        # Get bot token from session
        session_data = session.getSessionData()
        bot_token = session_data["shared"]["telegram"]["botToken"]

        self.poller = TelegramPoller(bot_token, self._handle_message)

    def start(self):
        """Start bot"""
        self.poller.start()
        sendToBot(self.session, "ü§ñ Bot ready! Type menu option numbers.")

        # Run menu loop in thread
        threading.Thread(target=self._run_menu, daemon=True).start()

    def _handle_message(self, update):
        """Queue user messages"""
        if "message" in update:
            text = update["message"].get("text", "")
            self.message_queue.put(text)

    def _run_menu(self):
        """Run menu() with hijacked stdin/stdout"""
        while True:
            with virtual_terminal(self.session, self.formatter, self.message_queue):
                menu(self.session)
```

**Key**: Single import `from ikabot.command_line import menu`, minimal code.

### 5. Entry Point (telegram_bot.py)

```python
#!/usr/bin/env python3
import sys
import time
import signal
from ikabot.web.session import Session
from plugins.telegram.bot import TelegramBot

def main():
    session = Session()
    if not session.logged:
        print("‚ùå Not logged in")
        return

    bot = TelegramBot(session)

    signal.signal(signal.SIGINT, lambda s, f: (bot.stop(), sys.exit(0)))

    bot.start()
    print("‚úÖ Bot running (Ctrl+C to stop)")

    while True:
        time.sleep(1)

if __name__ == "__main__":
    main()
```

## Critical Rules

### Zero Changes to Core
- ‚ùå NO changes to `ikabot/function/*.py`
- ‚ùå NO changes to `ikabot/command_line.py`
- ‚ùå NO changes to `ikabot/helpers/pedirInfo.py`
- ‚úÖ Only add files in `plugins/` directory
- ‚úÖ Use existing `sendToBot()` from `ikabot/helpers/botComm.py`
- ‚úÖ Use existing `requests` library (no new dependencies)

### Minimal Implementation
- ‚úÖ Prefer small, focused functions
- ‚úÖ Avoid boilerplate and abstractions
- ‚úÖ Use standard library (contextlib, queue, threading, re)
- ‚úÖ Keep total under 300 lines
- ‚úÖ Simple > Complex

### Testing Strategy
- Test by running `python telegram_bot.py`
- Send message "0" in Telegram ‚Üí should show menu
- Send message "17" ‚Üí should start autoPirate
- Answer questions via Telegram messages
- Verify CLI still works: `python ikabot`

## Expected Behavior

### User Flow Example

```
User sends: /start
Bot replies: ü§ñ Bot ready! Type menu option numbers.
             (0) Exit
             (1) Construction list
             ...
             (17) Auto Pirate

User sends: 17
Bot replies: ‚ö†Ô∏è WARNING ‚ö†Ô∏è
             How many pirate missions should I do? (min = 1)

User sends: 5
Bot replies: Do you want to schedule the task? [y/N]

User sends: n
Bot replies: Which mission duration? (1-9)

User sends: 3
Bot replies: ‚úÖ Task started!
             (Returns to menu)
```

### Key Success Criteria

1. ‚úÖ Zero core file modifications
2. ‚úÖ New functions added to core work automatically
3. ‚úÖ Function changes work automatically
4. ‚úÖ ANSI colors converted to Telegram formatting
5. ‚úÖ Alternating usage (Telegram ‚Üí CLI ‚Üí Telegram) works
6. ‚úÖ No new dependencies beyond what's already in ikabot

## Existing Infrastructure to Use

### Already Available (Don't Reimplement)

```python
# Telegram messaging
from ikabot.helpers.botComm import sendToBot

sendToBot(session, "text")  # Sends to configured Telegram chat

# Session management
from ikabot.web.session import Session

session = Session()  # Loads from ~/.ikabot
session_data = session.getSessionData()
bot_token = session_data["shared"]["telegram"]["botToken"]
chat_id = session_data["shared"]["telegram"]["chatId"]

# Menu system
from ikabot.command_line import menu

menu(session)  # Shows menu, handles all functions automatically
```

## Implementation Strategy

### Phase 1: Proof of Concept (1 day)
1. Create `virtual_terminal.py` with stdin/stdout classes
2. Create simple test script that hijacks stdin/stdout
3. Test that `input()` reads from queue, `print()` captures output

### Phase 2: Telegram Integration (1 day)
1. Create `poller.py` - verify messages received
2. Create `formatter.py` - test ANSI conversion
3. Test manual flow: poll message ‚Üí queue ‚Üí print to Telegram

### Phase 3: Full Bot (1 day)
1. Create `bot.py` - integrate all components
2. Test running menu() via Telegram
3. Test full function flow (autoPirate)

### Phase 4: Polish (1 day)
1. Add entry point `telegram_bot.py`
2. Add error handling
3. Test alternating CLI/Telegram usage
4. Document usage

**Total: 4 days**

## Example Code Pattern

```python
# Good: Minimal, focused
def readline(self):
    return self.queue.get() + "\n"

# Bad: Over-engineered
def readline(self, timeout=None, encoding='utf-8', errors='strict'):
    try:
        msg = self.queue.get(timeout=timeout or self.default_timeout)
        return msg.encode(encoding, errors=errors).decode() + "\n"
    except TimeoutError as e:
        raise InputTimeoutException(str(e)) from e
```

**Prefer the first approach** - simple, clear, maintainable.

## Common Pitfalls to Avoid

1. ‚ùå Don't import individual functions - only import `menu()`
2. ‚ùå Don't create function registry or metadata
3. ‚ùå Don't modify core files "just a little bit"
4. ‚ùå Don't add new dependencies
5. ‚ùå Don't over-abstract with base classes and inheritance
6. ‚úÖ Keep it simple and minimal

## Research-Based Best Practices

From Python 3.8+ standards (2024):
- Use `contextlib` context managers for resource management
- Use `threading.Thread(daemon=True)` for background tasks
- Use `queue.Queue` for thread-safe message passing
- Use `requests` library already present (no httpx/aiohttp needed)
- Keep regex patterns simple and explicit

## Questions to Verify Understanding

Before starting, ensure you can answer:
1. Why don't we need to import autoPirate or other functions?
2. How does the plugin work when core adds a new function?
3. Why can't CLI and Telegram run simultaneously?
4. What happens when we hijack sys.stdin?
5. How do ANSI codes get converted to Telegram format?

## Final Checklist

- [ ] Created 4 plugin files (total ~240 lines)
- [ ] Created entry point telegram_bot.py
- [ ] Zero changes to core files
- [ ] Tested via Telegram - menu shows
- [ ] Tested via Telegram - function works (autoPirate)
- [ ] Tested alternating usage (Telegram ‚Üí CLI)
- [ ] CLI still works independently: `python ikabot`
- [ ] No new dependencies added

## Start Implementation

Begin with:
```bash
mkdir -p plugins/telegram
touch plugins/telegram/__init__.py
touch plugins/telegram/virtual_terminal.py
```

Then implement `virtual_terminal.py` first (most critical component).

---

**Remember**: Simple, minimal, zero coupling. When in doubt, write less code.
